<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Deletando chaves do redis por pattern no dotnet - Yan Pitangui</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-2YDP77JD9X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2YDP77JD9X",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex Utilizando Redis, você deve estar utilizando algo como o seguinte para deletar chaves:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&#34;chave-1&#34;); await Cache.RemoveAsync(&#34;chave-2&#34;); await Cache.RemoveAsync(&#34;chave-3&#34;); } } O único problema dessa abordagem é que realizamos um round-trip para cada deleção de chave, ou seja, chamamos o servidor redis a cada deleção."><meta property="og:image" content><meta property="og:title" content="Deletando chaves do redis por pattern no dotnet"><meta property="og:description" content="Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex Utilizando Redis, você deve estar utilizando algo como o seguinte para deletar chaves:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&#34;chave-1&#34;); await Cache.RemoveAsync(&#34;chave-2&#34;); await Cache.RemoveAsync(&#34;chave-3&#34;); } } O único problema dessa abordagem é que realizamos um round-trip para cada deleção de chave, ou seja, chamamos o servidor redis a cada deleção."><meta property="og:type" content="article"><meta property="og:url" content="https://yanpitangui.com/pt/posts/2023/06/deletando-chaves-do-redis-por-pattern-no-dotnet/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-15T15:35:58-03:00"><meta property="article:modified_time" content="2023-06-15T15:35:58-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deletando chaves do redis por pattern no dotnet"><meta name=twitter:description content="Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex Utilizando Redis, você deve estar utilizando algo como o seguinte para deletar chaves:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&#34;chave-1&#34;); await Cache.RemoveAsync(&#34;chave-2&#34;); await Cache.RemoveAsync(&#34;chave-3&#34;); } } O único problema dessa abordagem é que realizamos um round-trip para cada deleção de chave, ou seja, chamamos o servidor redis a cada deleção."><script defer src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://yanpitangui.com/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://yanpitangui.com/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css disabled></head><body><div class=content><header><div class=main><a href=https://yanpitangui.com/>Yan Pitangui</a></div><nav><a href=/pt/posts/>Todos os posts</a>
<a href=/pt/tags/>Tags</a>
<a href=/pt/about/>Sobre mim</a>
| <span id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://yanpitangui.com/js/themetoggle.js></script><nav aria-label="Language switcher"><span aria-label=pt style="border-bottom:3px solid var(--callouctcolor)">pt</span>
<a title=en style=border:none href=https://yanpitangui.com/en/posts/2023/06/deleting-redis-keys-by-pattern-in-dotnet/ aria-label=en>en</a></nav></nav></header><main><article><div class=title><h1 class=title>Deletando chaves do redis por pattern no dotnet</h1><div class=meta>Postado em quinta-feira, 15 de junho de 2023</div></div><section class=body>2 minutos para ler<nav id=TableOfContents><ul><li><a href=#problema-você-quer-deletar-mais-de-uma-chave-de-uma-vez-provavelmente-por-um-padrão-regex>Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex</a></li><li><a href=#utilizando-regex-patterns-para-deletar-múltiplas-chaves>Utilizando regex patterns para deletar múltiplas chaves</a></li><li><a href=#links-relevantes>Links relevantes</a></li></ul></nav><h2 id=problema-você-quer-deletar-mais-de-uma-chave-de-uma-vez-provavelmente-por-um-padrão-regex>Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex</h2><p>Utilizando Redis, você deve estar utilizando algo como o seguinte para deletar chaves:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>CacheManager</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>readonly</span> IDistributedCache _cache;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>public</span> CacheManager(IDistributedCache cache) {
</span></span><span style=display:flex><span>        _cache = cache;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>public</span> <span style=color:#ff79c6>async</span> Task RemoveKeys() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> Cache.RemoveAsync(<span style=color:#f1fa8c>&#34;chave-1&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> Cache.RemoveAsync(<span style=color:#f1fa8c>&#34;chave-2&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> Cache.RemoveAsync(<span style=color:#f1fa8c>&#34;chave-3&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O único problema dessa abordagem é que realizamos um round-trip para cada deleção de chave, ou seja, chamamos o servidor redis a cada deleção.
Em momentos que a latência é importante, e da quantidade de chaves, isso pode fazer uma grande diferença.
E se pudéssemos deletar múltiplas chaves?</p><h2 id=utilizando-regex-patterns-para-deletar-múltiplas-chaves>Utilizando regex patterns para deletar múltiplas chaves</h2><p>A primeira mudança necessária é utilizar um IConnectionMultiplexer, pois precisaremos executar scripts diretamente na instância do redis.
Depois, executar um script Lua, que será o seguinte:</p><p><code>for i, name in ipairs(redis.call('KEYS', @prefix)) do redis.call('DEL', name); end</code></p><p>Voltando para o código, ficaríamos com algo como isso:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>CacheManager</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>readonly</span> IDistributedCache _cache; <span style=color:#6272a4>// Talvez você mantenha isso pra utilizar em outros métodos</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>readonly</span> IConnectionMultiplexer _multiplexer;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>public</span> CacheManager(IDistributedCache cache, IConnectionMultiplexer multiplexer)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _cache = cache;
</span></span><span style=display:flex><span>        _multiplexer = multiplexer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>public</span> <span style=color:#ff79c6>async</span> Task RemoveKeys(<span style=color:#8be9fd>string</span> prefix) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>var</span> prepared = LuaScript.Prepare(<span style=color:#f1fa8c>&#34;for i, name in ipairs(redis.call(&#39;KEYS&#39;, @prefix)) do redis.call(&#39;DEL&#39;, name); end&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> _multiplexer.GetDatabase().ScriptEvaluateAsync(prepared, <span style=color:#ff79c6>new</span> { prefix = prefix });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Aí, utilizamos assim:</span>
</span></span><span style=display:flex><span>... 
</span></span><span style=display:flex><span><span style=color:#ff79c6>await</span> manager.RemoveKeys(<span style=color:#f1fa8c>&#34;chave-*&#34;</span>);
</span></span></code></pre></div><h2 id=links-relevantes>Links relevantes</h2><ul><li><a href=https://stackexchange.github.io/StackExchange.Redis/Scripting>https://stackexchange.github.io/StackExchange.Redis/Scripting</a></li><li><a href=https://stackoverflow.com/a/27561399/12881014>https://stackoverflow.com/a/27561399/12881014</a></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/pt/tags/dotnet>dotnet</a></li><li><a href=/pt/tags/redis>redis</a></li><li><a href=/pt/tags/key>key</a></li><li><a href=/pt/tags/pattern>pattern</a></li><li><a href=/pt/tags/delete>delete</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/yanpitangui rel=me title=GitHub><i data-feather=github></i></a>
<span class=border></span><a class=soc href=https://twitter.com/aethelingaeg rel=me title=Twitter><i data-feather=twitter></i></a>
<span class=border></span><a class=soc href=https://www.linkedin.com/in/yanpitangui/ rel=me title=Linkedin><i data-feather=linkedin></i></a>
<span class=border></span></div><div class=footer-info>2023 © Yan Pitangui | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>document.addEventListener("DOMContentLoaded",()=>feather.replace())</script></div></body></html>