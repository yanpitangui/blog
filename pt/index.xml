<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yan Pitangui</title><link>https://yanpitangui.com/pt/</link><description>Recent content on Yan Pitangui</description><generator>Hugo -- gohugo.io</generator><language>pt</language><copyright>© Yan Pitangui</copyright><lastBuildDate>Thu, 15 Jun 2023 15:35:58 -0300</lastBuildDate><atom:link href="https://yanpitangui.com/pt/index.xml" rel="self" type="application/rss+xml"/><item><title>Deletando chaves do redis por pattern no dotnet</title><link>https://yanpitangui.com/pt/posts/2023/06/deletando-chaves-do-redis-por-pattern-no-dotnet/</link><pubDate>Thu, 15 Jun 2023 15:35:58 -0300</pubDate><guid>https://yanpitangui.com/pt/posts/2023/06/deletando-chaves-do-redis-por-pattern-no-dotnet/</guid><description>Problema: Você quer deletar mais de uma chave de uma vez, provavelmente por um padrão regex Utilizando Redis, você deve estar utilizando algo como o seguinte para deletar chaves:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&amp;#34;chave-1&amp;#34;); await Cache.RemoveAsync(&amp;#34;chave-2&amp;#34;); await Cache.RemoveAsync(&amp;#34;chave-3&amp;#34;); } } O único problema dessa abordagem é que realizamos um round-trip para cada deleção de chave, ou seja, chamamos o servidor redis a cada deleção.</description></item><item><title>Detectando se a aplicação está rodando para criar migrations</title><link>https://yanpitangui.com/pt/posts/2023/06/detectando-se-a-aplica%C3%A7%C3%A3o-est%C3%A1-rodando-para-criar-migrations/</link><pubDate>Thu, 15 Jun 2023 00:52:58 -0300</pubDate><guid>https://yanpitangui.com/pt/posts/2023/06/detectando-se-a-aplica%C3%A7%C3%A3o-est%C3%A1-rodando-para-criar-migrations/</guid><description>Problema: Seu DbContext tem uma dependência scoped Tendo uma dependência scoped, como por exemplo numa aplicação multi tenant, onde injeta algum serviço scoped, como TenantProvider ou algo do tipo, você ficará impossibilitado(a) de criar migrations, pois a aplicação não conseguirá resolver essa dependência. Mas eu tenho a solução!
Veja a classe a seguir como exemplo:
public class Session: ISession { public Session(IHttpContextAccessor httpContextAccessor) {...} } Solução Uma coisa que pode ser feita é adicionar mais um construtor, onde você adiciona manualmente as dependências, como a seguir:</description></item><item><title>Iniciando uma api em .NET rapidamente com um boilerplate</title><link>https://yanpitangui.com/pt/posts/2023/05/iniciando-uma-api-em-.net-rapidamente-com-um-boilerplate/</link><pubDate>Wed, 10 May 2023 21:56:13 -0300</pubDate><guid>https://yanpitangui.com/pt/posts/2023/05/iniciando-uma-api-em-.net-rapidamente-com-um-boilerplate/</guid><description>O que é um boilerplate de API? Um boilerplate de API é um modelo pré-construído que fornece uma estrutura básica e um conjunto de funcionalidades para criar uma API da Web. Ele inclui componentes essenciais, como roteamento, integração de banco de dados, tratamento de erros e recursos de segurança que geralmente são necessários na maioria dos projetos de API.
Por que você deveria se preocupar com isso? O uso de um boilerplate de API pode acelerar significativamente o processo de desenvolvimento inicial por vários motivos:</description></item><item><title>Sobre mim</title><link>https://yanpitangui.com/pt/about/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://yanpitangui.com/pt/about/</guid><description>Olá, sou Yan Pitangui, um desenvolvedor de software baseado no Brasil. Comecei como desenvolvedor fullstack, mas com o tempo me concentrei em back-end e Azure. Eu gosto muito de trabalhar com C#/.NET, JS/TS e também comecei a aprender Rust. Ultimamente tenho estudado computação nativa em nuvem (com Orleans) e observabilidade (com OpenTelemetry). Aqui você encontrará material que compartilho na esperança de que seja útil para alguém.
Minhas certificações:</description></item></channel></rss>