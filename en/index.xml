<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yan Pitangui</title><link>https://yanpitangui.com/en/</link><description>Recent content on Yan Pitangui</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© Yan Pitangui</copyright><lastBuildDate>Thu, 15 Jun 2023 15:35:58 -0300</lastBuildDate><atom:link href="https://yanpitangui.com/en/index.xml" rel="self" type="application/rss+xml"/><item><title>Deleting Redis keys by pattern in dotnet</title><link>https://yanpitangui.com/en/posts/2023/06/deleting-redis-keys-by-pattern-in-dotnet/</link><pubDate>Thu, 15 Jun 2023 15:35:58 -0300</pubDate><guid>https://yanpitangui.com/en/posts/2023/06/deleting-redis-keys-by-pattern-in-dotnet/</guid><description>Problem: You want to delete more than one key at a time, probably by regex pattern Using Redis, you might be using something like the following to delete keys:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&amp;#34;key-1&amp;#34;); await Cache.RemoveAsync(&amp;#34;key-2&amp;#34;); await Cache.RemoveAsync(&amp;#34;key-3&amp;#34;); } } The only problem with this approach is that we perform a round-trip for each key deletion, that is, we call the redis server at each deletion.</description></item><item><title>Detecting if the application is running to create migrations</title><link>https://yanpitangui.com/en/posts/2023/06/detecting-if-the-application-is-running-to-create-migrations/</link><pubDate>Thu, 15 Jun 2023 00:52:58 -0300</pubDate><guid>https://yanpitangui.com/en/posts/2023/06/detecting-if-the-application-is-running-to-create-migrations/</guid><description>Problem: Your DbContext has a scoped dependency Having a scoped dependency, for example in a multi-tenant application, where it injects some scoped service, such as TenantProvider or something like that, you will be unable to create migrations, as the application will not be able to resolve this dependency. But I have the solution!
See the following class as an example:
public class Session: ISession { public Session(IHttpContextAccessor httpContextAccessor) {...} } Solution One thing you can do is add one more constructor, where you manually add dependencies, like this:</description></item><item><title>Starting a .NET api quickly with a boilerplate</title><link>https://yanpitangui.com/en/posts/2023/05/starting-a-.net-api-quickly-with-a-boilerplate/</link><pubDate>Wed, 10 May 2023 21:56:13 -0300</pubDate><guid>https://yanpitangui.com/en/posts/2023/05/starting-a-.net-api-quickly-with-a-boilerplate/</guid><description>What is an API boilerplate? An API boilerplate is a pre-built template that provides a basic structure and set of functionalities for creating a web API. It includes essential components such as routing, database integration, error handling, and security features that are commonly required in most API projects.
Why should you care about it? Using an API boilerplate can significantly speed up the initial development process for several reasons:
Provides a Structured and Consistent Framework: An API boilerplate offers a clear and structured framework to start from, ensuring that the codebase remains organized and consistent.</description></item><item><title>About me</title><link>https://yanpitangui.com/en/about/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://yanpitangui.com/en/about/</guid><description>Hello, I&amp;rsquo;m Yan Pitangui, a software developer based in Brazil. I started as a fullstack developer, but over time I focused on backend and Azure. I really like working with C#/.NET, JS/TS and I also started to learn Rust. Lately I&amp;rsquo;ve been studying cloud native computing (with Orleans) and observability (with OpenTelemetry). Here you will find material that I share in the hope that it will be useful to someone.</description></item></channel></rss>