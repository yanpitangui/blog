<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>migrations on Yan Pitangui</title><link>https://yanpitangui.com/en/tags/migrations/</link><description>Recent content in migrations on Yan Pitangui</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© Yan Pitangui</copyright><lastBuildDate>Thu, 15 Jun 2023 00:52:58 -0300</lastBuildDate><atom:link href="https://yanpitangui.com/en/tags/migrations/index.xml" rel="self" type="application/rss+xml"/><item><title>Detecting if the application is running to create migrations</title><link>https://yanpitangui.com/en/posts/2023/06/detecting-if-the-application-is-running-to-create-migrations/</link><pubDate>Thu, 15 Jun 2023 00:52:58 -0300</pubDate><guid>https://yanpitangui.com/en/posts/2023/06/detecting-if-the-application-is-running-to-create-migrations/</guid><description>Problem: Your DbContext has a scoped dependency Having a scoped dependency, for example in a multi-tenant application, where it injects some scoped service, such as TenantProvider or something like that, you will be unable to create migrations, as the application will not be able to resolve this dependency. But I have the solution!
See the following class as an example:
public class Session: ISession { public Session(IHttpContextAccessor httpContextAccessor) {...} } Solution One thing you can do is add one more constructor, where you manually add dependencies, like this:</description></item></channel></rss>