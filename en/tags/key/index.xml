<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>key on Yan Pitangui</title><link>https://yanpitangui.com/en/tags/key/</link><description>Recent content in key on Yan Pitangui</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© Yan Pitangui</copyright><lastBuildDate>Thu, 15 Jun 2023 15:35:58 -0300</lastBuildDate><atom:link href="https://yanpitangui.com/en/tags/key/index.xml" rel="self" type="application/rss+xml"/><item><title>Deleting Redis keys by pattern in dotnet</title><link>https://yanpitangui.com/en/posts/2023/06/deleting-redis-keys-by-pattern-in-dotnet/</link><pubDate>Thu, 15 Jun 2023 15:35:58 -0300</pubDate><guid>https://yanpitangui.com/en/posts/2023/06/deleting-redis-keys-by-pattern-in-dotnet/</guid><description>Problem: You want to delete more than one key at a time, probably by regex pattern Using Redis, you might be using something like the following to delete keys:
public class CacheManager { private readonly IDistributedCache _cache; public CacheManager(IDDistributedCache cache) { _cache = cache; } public async Task RemoveKeys() { await Cache.RemoveAsync(&amp;#34;key-1&amp;#34;); await Cache.RemoveAsync(&amp;#34;key-2&amp;#34;); await Cache.RemoveAsync(&amp;#34;key-3&amp;#34;); } } The only problem with this approach is that we perform a round-trip for each key deletion, that is, we call the redis server at each deletion.</description></item></channel></rss>